#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 6364136223846793005 32 4294967295 1442695040888963407 1442695040888963409 1442695040888963411 1442695040888963413 TMPL_VERIFIABLE_SHUFFLE_OPUP TMPL_RANDOMNESS_BEACON TMPL_SAFETY_ROUND_GAP
    bytecblock 0x 0x151f7c75 "commitment" 0x01 0x0000 0x0100000000000000000000000000000000
    txn NumAppArgs
    bz main_bare_routing@15
    pushbytess 0x50724384 0x33ce11eb // method "commit(uint8,uint32,uint8)void", method "reveal()(byte[32],uint32[])"
    txna ApplicationArgs 0
    match main_commit_route@5 main_reveal_route@6

main_switch_case_next@7:
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0x7aeb233d 0xe4efe5ff 0x59827455 // method "get_templated_randomness_beacon_id()uint64", method "get_templated_opup_id()uint64", method "get_templated_safety_round_gap()uint64"
    txna ApplicationArgs 0
    match get_templated_randomness_beacon_id get_templated_opup_id get_templated_safety_round_gap

main_after_if_else@20:
    err

main_reveal_route@6:
    intc_0 // 1
    txn OnCompletion
    shl
    pushint 5
    &
    txn ApplicationID
    &&
    assert
    b reveal

main_commit_route@5:
    intc_0 // 1
    txn OnCompletion
    shl
    pushint 3
    &
    txn ApplicationID
    &&
    assert
    b commit

main_bare_routing@15:
    txn OnCompletion
    switch main___algopy_default_create@16 main_after_if_else@20 main_after_if_else@20 main_after_if_else@20 main_update@17 main_delete@18
    err

main_delete@18:
    txn ApplicationID
    assert
    txn Sender
    global CreatorAddress
    ==
    assert // Address is not the creator
    intc_0 // 1
    return

main_update@17:
    txn ApplicationID
    assert
    txn Sender
    global CreatorAddress
    ==
    assert // Address is not the creator
    intc_0 // 1
    return

main___algopy_default_create@16:
    txn ApplicationID
    !
    return


// lib_pcg.pcg128.__pcg128_unbounded_random(state.0: uint64, state.1: uint64, state.2: uint64, state.3: uint64) -> uint64, uint64, uint64, uint64, bytes:
__pcg128_unbounded_random:
    proto 4 5
    frame_dig -4
    intc_2 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963407
    addw
    bury 1
    dup
    !
    intc 6 // 1442695040888963409
    swap
    shl
    frame_dig -3
    intc_2 // 6364136223846793005
    mulw
    bury 1
    addw
    bury 1
    dup
    !
    intc 7 // 1442695040888963411
    swap
    shl
    frame_dig -2
    intc_2 // 6364136223846793005
    mulw
    bury 1
    addw
    bury 1
    dup
    !
    intc 8 // 1442695040888963413
    swap
    shl
    frame_dig -1
    intc_2 // 6364136223846793005
    mulw
    bury 1
    addw
    bury 1
    frame_dig -4
    pushint 18
    shr
    frame_dig -4
    ^
    pushint 27
    shr
    intc 4 // 4294967295
    &
    frame_dig -4
    pushint 59
    shr
    dup2
    shr
    swap
    ~
    intc_0 // 1
    addw
    bury 1
    pushint 31
    &
    uncover 2
    swap
    shl
    intc 4 // 4294967295
    &
    |
    intc_3 // 32
    shl
    frame_dig -3
    pushint 18
    shr
    frame_dig -3
    ^
    pushint 27
    shr
    intc 4 // 4294967295
    &
    frame_dig -3
    pushint 59
    shr
    dup2
    shr
    swap
    ~
    intc_0 // 1
    addw
    bury 1
    pushint 31
    &
    uncover 2
    swap
    shl
    intc 4 // 4294967295
    &
    |
    |
    itob
    frame_dig -2
    pushint 18
    shr
    frame_dig -2
    ^
    pushint 27
    shr
    intc 4 // 4294967295
    &
    frame_dig -2
    pushint 59
    shr
    dup2
    shr
    swap
    ~
    intc_0 // 1
    addw
    bury 1
    pushint 31
    &
    uncover 2
    swap
    shl
    intc 4 // 4294967295
    &
    |
    intc_3 // 32
    shl
    frame_dig -1
    pushint 18
    shr
    frame_dig -1
    ^
    pushint 27
    shr
    intc 4 // 4294967295
    &
    frame_dig -1
    pushint 59
    shr
    dup2
    shr
    swap
    ~
    intc_0 // 1
    addw
    bury 1
    pushint 31
    &
    uncover 2
    swap
    shl
    intc 4 // 4294967295
    &
    |
    |
    itob
    concat
    retsub


// smart_contracts.verifiable_shuffle.contract.binary_logarithm(n: uint64, m: uint64) -> uint64:
binary_logarithm:
    proto 2 1
    bytec_0 // ""
    dup
    frame_dig -2
    bitlen
    intc_0 // 1
    -
    dup
    intc_0 // 1
    swap
    shl
    dup
    frame_dig -2
    ==
    bz binary_logarithm_after_if_else@2
    frame_dig 2
    frame_dig -1
    shl
    frame_bury 0
    retsub

binary_logarithm_after_if_else@2:
    intc_1 // 0
    frame_bury 1
    intc_1 // 0
    frame_bury 0

binary_logarithm_for_header@3:
    frame_dig 0
    frame_dig -1
    <
    bz binary_logarithm_after_for@8
    frame_dig 1
    intc_0 // 1
    shl
    frame_bury 1
    frame_dig -2
    dup
    mulw
    frame_dig 3
    divw
    frame_bury -2
    pushint 2
    frame_dig 2
    shl
    frame_dig -2
    <=
    bz binary_logarithm_after_if_else@6
    frame_dig 1
    intc_0 // 1
    |
    frame_bury 1
    frame_dig -2
    intc_0 // 1
    shr
    frame_bury -2

binary_logarithm_after_if_else@6:
    frame_dig 0
    intc_0 // 1
    +
    frame_bury 0
    b binary_logarithm_for_header@3

binary_logarithm_after_for@8:
    frame_dig 2
    frame_dig -1
    shl
    frame_dig 1
    |
    frame_bury 0
    retsub


// smart_contracts.verifiable_shuffle.contract.linear_search(bin_list: bytes, key: uint64) -> uint64, uint64, uint64:
linear_search:
    proto 2 3
    frame_dig -2
    len
    intc_1 // 0

linear_search_for_header@1:
    frame_dig 1
    frame_dig 0
    <
    bz linear_search_after_for@6
    frame_dig -2
    frame_dig 1
    extract_uint32
    frame_dig -1
    ==
    bz linear_search_after_if_else@4
    frame_dig 1
    dup
    pushint 4
    +
    frame_dig -2
    swap
    extract_uint32
    intc_0 // 1
    cover 2
    uncover 4
    uncover 4
    retsub

linear_search_after_if_else@4:
    frame_dig 1
    pushint 8
    +
    frame_bury 1
    b linear_search_for_header@1

linear_search_after_for@6:
    intc_1 // 0
    dupn 2
    uncover 4
    uncover 4
    retsub


// smart_contracts.verifiable_shuffle.contract.VerifiableShuffle.get_templated_randomness_beacon_id[routing]() -> void:
get_templated_randomness_beacon_id:
    intc 10 // TMPL_RANDOMNESS_BEACON
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.verifiable_shuffle.contract.VerifiableShuffle.get_templated_opup_id[routing]() -> void:
get_templated_opup_id:
    intc 9 // TMPL_VERIFIABLE_SHUFFLE_OPUP
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.verifiable_shuffle.contract.VerifiableShuffle.get_templated_safety_round_gap[routing]() -> void:
get_templated_safety_round_gap:
    intc 11 // TMPL_SAFETY_ROUND_GAP
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.verifiable_shuffle.contract.VerifiableShuffle.commit[routing]() -> void:
commit:
    bytec_0 // ""
    dupn 7
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    txna ApplicationArgs 2
    dup
    cover 2
    len
    pushint 4
    ==
    assert // invalid number of bytes for arc4.uint32
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    swap
    btoi
    dup
    cover 2
    intc 11 // TMPL_SAFETY_ROUND_GAP
    >=
    assert // The round delay is less than the safety parameters
    btoi
    dup
    bz commit_bool_false@4
    dup
    pushint 35
    <
    bz commit_bool_false@4
    intc_0 // 1

commit_bool_merge@5:
    assert // There must be at least one winner and less than 35
    dig 3
    btoi
    dup
    bury 8
    dup
    pushint 2
    >=
    assert // There must be at least two participants
    dig 1
    dup
    uncover 2
    <=
    assert // Winners must be less than or equal to Participants
    pushint 600
    *
    pushint 700
    /
    intc_0 // 1
    +
    bury 10
    intc_1 // 0
    bury 12

commit_for_header@6:
    dig 11
    dig 10
    <
    bz commit_after_for@10
    itxn_begin
    intc 9 // TMPL_VERIFIABLE_SHUFFLE_OPUP
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    dig 11
    intc_0 // 1
    +
    bury 12
    b commit_for_header@6

commit_after_for@10:
    intc_0 // 1
    bury 9
    intc_1 // 0
    bury 6
    dig 6
    dup
    intc_0 // 1
    +
    bury 6
    dig 1
    -
    intc_0 // 1
    +
    bury 11

commit_for_header@12:
    dig 10
    dig 5
    <
    bz commit_after_for@18
    dig 8
    dig 11
    mulw
    bury 9
    bnz commit_if_body@15
    dig 7
    bitlen
    pushint 64
    ==
    bz commit_else_body@16

commit_if_body@15:
    dig 8
    pushint 16
    callsub binary_logarithm
    dig 6
    +
    bury 6
    dig 10
    bury 9

commit_after_if_else@17:
    dig 10
    intc_0 // 1
    +
    bury 11
    b commit_for_header@12

commit_else_body@16:
    dig 8
    dig 11
    *
    bury 9
    b commit_after_if_else@17

commit_after_for@18:
    dig 8
    pushint 16
    callsub binary_logarithm
    dig 6
    +
    pushint 8388608
    <=
    assert // The number of k-permutation exceeds the safety parameters
    txn TxID
    global Round
    dig 3
    +
    itob
    concat
    dig 4
    concat
    dig 3
    concat
    txn Sender
    bytec_2 // "commitment"
    uncover 2
    app_local_put
    intc_0 // 1
    return

commit_bool_false@4:
    intc_1 // 0
    b commit_bool_merge@5


// smart_contracts.verifiable_shuffle.contract.VerifiableShuffle.reveal[routing]() -> void:
reveal:
    intc_1 // 0
    dupn 6
    bytec_0 // ""
    dupn 11
    txn Sender
    intc_1 // 0
    bytec_2 // "commitment"
    app_local_get_ex
    assert // check self.commitment exists for account
    txn Sender
    bytec_2 // "commitment"
    app_local_del
    dup
    pushint 40
    extract_uint32
    swap
    dup
    pushint 44
    getbyte
    swap
    global Round
    dig 1
    extract 32 8
    dig 2
    intc_3 // 32
    extract_uint64
    uncover 2
    <=
    assert // The committed round has not elapsed yet
    itxn_begin
    swap
    extract 0 32
    dup
    cover 2
    pushbytes 0x0020
    swap
    concat
    intc 10 // TMPL_RANDOMNESS_BEACON
    itxn_field ApplicationID
    pushbytes 0x47c20c23 // method "must_get(uint64,byte[])byte[]"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 4 0
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // application log value is not the result of an ABI return
    intc_1 // 0

reveal_for_header@3:
    dup
    pushint 11
    <
    bz reveal_after_for@6
    dupn 2
    bytec_0 // 0x
    stores
    intc_0 // 1
    +
    bury 1
    b reveal_for_header@3

reveal_after_for@6:
    dig 3
    pushint 500
    *
    pushint 700
    /
    intc_0 // 1
    +
    bury 14
    intc_1 // 0
    bury 17

reveal_for_header@7:
    dig 16
    dig 14
    <
    bz reveal_after_for@11
    itxn_begin
    intc 9 // TMPL_VERIFIABLE_SHUFFLE_OPUP
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    dig 16
    intc_0 // 1
    +
    bury 17
    b reveal_for_header@7

reveal_after_for@11:
    dig 3
    dig 5
    <
    bz reveal_ternary_false@13
    dig 3
    bury 11

reveal_ternary_merge@14:
    dig 1
    extract 6 0
    dup
    len
    intc_3 // 32
    ==
    assert
    dup
    intc_1 // 0
    extract_uint64
    intc_1 // 0
    intc_2 // 6364136223846793005
    mulw
    bury 1
    dup
    intc 5 // 1442695040888963407
    addw
    bury 1
    uncover 2
    addw
    bury 1
    intc_2 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963407
    addw
    cover 3
    pop
    dig 1
    pushint 8
    extract_uint64
    dig 1
    intc 6 // 1442695040888963409
    addw
    bury 1
    addw
    bury 1
    intc_2 // 6364136223846793005
    mulw
    bury 1
    intc 6 // 1442695040888963409
    addw
    cover 3
    pop
    dig 1
    pushint 16
    extract_uint64
    dig 1
    intc 7 // 1442695040888963411
    addw
    bury 1
    addw
    bury 1
    intc_2 // 6364136223846793005
    mulw
    bury 1
    intc 7 // 1442695040888963411
    addw
    cover 3
    pop
    swap
    pushint 24
    extract_uint64
    swap
    intc 8 // 1442695040888963413
    addw
    bury 1
    addw
    bury 1
    intc_2 // 6364136223846793005
    mulw
    bury 1
    intc 8 // 1442695040888963413
    addw
    bury 1
    bytec 4 // 0x0000
    bury 22
    intc_1 // 0
    swap
    bury 11
    swap
    bury 11
    swap
    bury 11
    swap
    bury 11
    bury 1

reveal_for_header@15:
    dup
    dig 11
    <
    bz reveal_after_for@21
    dup
    itob
    dup
    bury 23
    dig 5
    itob
    bury 20
    bytec 4 // 0x0000
    bury 22
    bytec_0 // 0x
    b==
    bz reveal_else_body@30
    dig 18
    bytec_0 // 0x
    b==
    bz reveal_else_body@30
    intc_1 // 0
    bury 16

reveal_for_header@27:
    dig 15
    intc_0 // 1
    <
    bz reveal_after_if_else@40
    dig 9
    dig 9
    dig 9
    dig 9
    callsub __pcg128_unbounded_random
    cover 4
    bury 11
    bury 11
    bury 11
    bury 11
    dup
    len
    pushint 16
    <=
    assert // overflow
    pushint 16
    bzero
    b|
    dig 21
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 21
    dig 15
    intc_0 // 1
    +
    bury 16
    b reveal_for_header@27

reveal_after_if_else@40:
    dig 20
    extract 2 16
    pushint 12
    extract_uint32
    dup
    bury 14
    dig 1
    dup
    pushint 11
    %
    loads
    dig 1
    callsub linear_search
    cover 2
    pop
    select
    bury 16
    dup
    pushint 11
    %
    dup
    bury 8
    loads
    dup
    cover 2
    dig 1
    callsub linear_search
    cover 2
    bury 16
    cover 2
    dig 2
    select
    itob
    dup
    bitlen
    intc_3 // 32
    <=
    assert // overflow
    extract 4 4
    dig 20
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 20
    bz reveal_else_body@18
    dig 12
    pushint 4
    +
    dig 16
    itob
    dup
    bitlen
    intc_3 // 32
    <=
    assert // overflow
    extract 4 4
    replace3

reveal_after_if_else@19:
    dig 6
    swap
    stores
    dup
    intc_0 // 1
    +
    bury 1
    b reveal_for_header@15

reveal_else_body@18:
    dig 13
    itob
    dup
    bitlen
    intc_3 // 32
    <=
    assert // overflow
    extract 4 4
    dig 16
    itob
    dup
    bitlen
    intc_3 // 32
    <=
    assert // overflow
    extract 4 4
    concat
    concat
    b reveal_after_if_else@19

reveal_else_body@30:
    dig 18
    bytec_0 // 0x
    b!=
    bz reveal_else_body@32
    dig 18
    dup
    bytec_3 // 0x01
    b>
    assert
    dup
    bytec 5 // 0x0100000000000000000000000000000000
    b<
    assert
    dup
    bytec_3 // 0x01
    b-
    dig 23
    dup
    uncover 2
    b<
    assert
    b-
    bury 24

reveal_after_if_else@33:
    dig 23
    dup
    b~
    bytec_3 // 0x01
    b+
    pushbytes 0xffffffffffffffffffffffffffffffff
    b&
    swap
    b%
    bury 20
    intc_1 // 0
    bury 16

reveal_for_header@34:
    dig 15
    intc_0 // 1
    <
    bz reveal_after_if_else@40

reveal_while_top@36:
    dig 9
    dig 9
    dig 9
    dig 9
    callsub __pcg128_unbounded_random
    dup
    cover 5
    bury 28
    bury 11
    bury 11
    bury 11
    bury 11
    dig 20
    b>=
    bz reveal_while_top@36
    dig 22
    dig 24
    b%
    dig 22
    b+
    dup
    len
    pushint 16
    <=
    assert // overflow
    pushint 16
    bzero
    b|
    dig 21
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 21
    dig 15
    intc_0 // 1
    +
    bury 16
    b reveal_for_header@34

reveal_else_body@32:
    dig 21
    dup
    pushbytes 0x80000000000000000000000000000000
    b<
    assert
    bytec 5 // 0x0100000000000000000000000000000000
    swap
    b-
    bury 24
    b reveal_after_if_else@33

reveal_after_for@21:
    dig 4
    dig 4
    ==
    bz reveal_after_if_else@23
    dig 3
    intc_0 // 1
    -
    dup
    pushint 11
    %
    loads
    dig 1
    callsub linear_search
    cover 2
    pop
    select
    itob
    dup
    bitlen
    intc_3 // 32
    <=
    assert // overflow
    extract 4 4
    dig 18
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 18

reveal_after_if_else@23:
    dig 2
    pushbytes 0x0022
    concat
    dig 18
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

reveal_ternary_false@13:
    dig 3
    intc_0 // 1
    -
    bury 11
    b reveal_ternary_merge@14
